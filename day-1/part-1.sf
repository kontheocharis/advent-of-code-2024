-- UTILS

#unfold
def return : [A : Type] -> A -> IO A {
  io-return
}

#unfold
def bind : [A B : Type] -> IO A -> (A -> IO B) -> IO B {
  io-bind
}

def lines : String -> List String {
  \s => filter (\x => not (string-eq x "")) (string-split s "\n")
}

def words : String -> List String {
  \s => filter (\x => not (string-eq x "")) (string-split s " ")
}

def first-two : [A : Type] -> List A -> Maybe (A * A) {
  \case {
    [] => nothing,
    [x, ..xs] => case xs {
      [] => nothing,
      [y, .._] => just (x, y)
    }
  }
}

def forM : [A B : Type] -> List A -> (A -> IO B) -> IO (List B) {
  \l f => case l {
    [] => return [],
    [x, ..xs] => {
      let y <- f x;
      let ys <- forM xs f;
      return [y, ..ys]
    }
  }
}

def parse-natM : String -> IO Nat {
  \s => case parse-nat s {
    nothing => throw (string-concat "Invalid input: " s),
    just n => return n
  }
}

def zip : [A B : Type] -> List A -> List B -> List (A * B) {
  \l r => case l {
    [] => [],
    [x, ..xs] => case r {
      [] => [],
      [y, ..ys] => [(x, y), ..zip xs ys]
    }
  }
}

def unzip : [A B : Type] -> List (A * B) -> (List A * List B) {
  \case {
    [] => ([], []),
    [m, ..xs] => {
      let (x, y) = m;
      let (l, r) = unzip xs;
      ([x, ..l], [y, ..r])
    }
  }
}

-- PROGRAM

def list-distance : List Nat -> List Nat -> Nat {
  \l r => {
    fold 0 (\ls acc => {
      let (x, y) : Nat * Nat = ls;
      if lt x y {
        add acc (sub y x)
      } else {
        add acc (sub x y)
      }
    }) (zip l r)
  }
}

def main : IO () {
  let txt <- input;

  let numbers <- forM (lines txt) (\line => {
    case first-two (words line) {
      nothing => throw "Invalid input",
      just ws => {
        let (a, b) = ws;
        let a' <- parse-natM a;
        let b' <- parse-natM b;
        return (a', b')
      }
    }
  });

  let (l, r) = unzip numbers;
  let result = list-distance (sort nat-cmp l) (sort nat-cmp r);

  print (show-nat result)
}
